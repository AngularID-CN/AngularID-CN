# 关于Angular变更检测不那么硬核的介绍

> 原文链接: [A gentle introduction into change detection in Angular](https://blog.angularindepth.com/a-gentle-introduction-into-change-detection-in-angular-33f9ffff6f10)

> 原文作者: [Max Koretskyi, aka Wizard](https://blog.angularindepth.com/@maxim.koretskyi?source=post_header_lockup)

![one-way new-way](../assets/135/1.jpeg)

> 如果你更希望通过视频的方式了解这篇文章,[可以查看原作在`AngularConnect`上所做的演讲](https://www.youtube.com/watch?v=DsBy9O0c6eo)

> 为了行文方便,下文均已`我`指代原作者
现代web应用都是交互式的。web应用的状态随时都可能发生变化,而产生变化的原因可能是一个按钮的点击或从服务器返回的一个请求。代码需要检测到应用的状态发生变化并及时将变化反射到用户UI界面上,而这就是变更检测机制的主要工作。

在过去的一年中,我已经写了一系列有关Angular变更检测的[InDepth文章](https://blog.angularindepth.com/these-5-articles-will-make-you-an-angular-change-detection-expert-ed530d28930)。这些文章对变更检测给出了详细的解释并且覆盖了很多内部的相关细节,但是这也意味着你可能需要花费不少的时间去读完,读透全部的内容。对于那些没有那么多时间但是仍然对Angular变更检测好奇的读者,本文将会以轻量级的方式介绍变更检测机制。本文将会从高阶的角度给出一个关于变更检测的组成部分和机制的概述性总结:用于代表组件的内部数据结构,绑定在其中的角色以及作为其流程一部分的操作。我也会涉及`zones`的概念并向你准确地展示其如何在Angular中启用自动变更检测。

当Angular应用出错时,关于变更检测及其更深层次的知识会帮助你debug你的应用,比如[ExpressionChangedAfterItHasBeenCheckedError](https://blog.angularindepth.com/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4)这个错误,更加有效地帮你避免一些常见的[困惑](https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5)。在本文中,我将演示一些导致错误的设置,并使用它们来解释变更检测及其内部的相关内容。

## 初次接触

让我们从一个简单的Angular组件开始,它呈现了在应用中发生变更检测时的时刻,其时间戳具有毫秒的精度。点击按钮以触发变更检测：

![样本gif](../assets/135/2.gif)

> [Demo地址](https://stackblitz.com/edit/angular-hqbenm?file=src/app/app.component.ts)

以下为实现:

```typescript
@Component({
    selector: 'my-app',
    template: `
        <h3>
            Change detection is triggered at:
            <span [textContent]="time | date:'hh:mm:ss:SSS'"></span>
        </h3>
        <button (click)="0">Trigger Change Detection</button>
    `
})
export class AppComponent {
    get time() {
        return Date.now();
    }
}
```

正如你所见的那样这是一个很简单的实践,有一个名为`time`的`getter`函数返回当前时间戳并将它绑定到HTML中的span元素上。

> Angular并不允许空的表达式,所以这里使用`0`作为点击事件的回调

你可以在[这里](https://stackblitz.com/edit/angular-hqbenm?file=src/app/app.component.ts)进行你自己的尝试。当Angular执行变更检测时,它获取了time属性的值将它传递给`date`管道并使用其结果更新DOM。目前为止一切都正常运作。然而当我检查控制台的时候看到了`ExpressionChangedAfterItHasBeenCheckedError`这个错误

![ExpressionChangedAfterItHasBeenCheckedError错误](../assets/135/3.png)

这着实让人惊讶,通常而言这个错误会伴随更加复杂的场景出现。那么我们是如何通过如此简单的功能产生了这个错误呢？别担心,我们好好调查一下。

让我们从错误信息开始:

> Expression has changed after it was checked. Previous value: “textContent: 1542375826274”. Current value: “textContent: 1542375826275”.

这条错误信息告诉我们由表达式生成的用于`textContent`绑定的值是不同的。是的,毫秒数的确不同。所以Angular评估了表达式`time | date:’hh:mm:ss:SSS`两次并比较了两次的结果。Angular检测到了不同,并因此触发了错误。

### 但为什么Angular会进行这种比较呢？
### 或这种比较究竟是什么时候做的呢？

这些问题引起了我的好奇心,并最终导致我钻入变化检测的内部世界。为了找到这些问题的答案,我必须开始调试,于是我度过了长达几个月不停调试的时光😅。让我们从第二个问题(这个错误何时被抛出)开始,但在那之前,我需要与你分享一些我的发现,这些发现将有助于我们理解上面那些刚刚观察到的表现/行为

## 组件视图和绑定

在Angular中有两个关于变更检测的主要构建块 `building blocks` :

- 组件视图 `a component view`
- 相关绑定 `the associated bindings`

Angular中的每个组件都包含一个带有HTML元素的模版。当Angular创建DOM节点以在屏幕上呈现模板的内容时,它需要一个位置来存储这些DOM节点的引用。为了这个目的,内部有一个称为View的数据结构。它也用于存储组件实例的引用以及绑定表达式 `binding expressions` 的前值。组件和视图之间存在一对一的关系, 下面的图表用于展示View的含义

![View的含义](../assets/135/4.png)

当编译器分析模板时,它会识别在变更检测期间可能需要更新的DOM元素的属性, 对于每个这样的属性,编译器都会创建一个绑定。绑定定义了要更新的属性名称和Angular用于获取新值的表达式。

在我们的示例中,属性 `time` 在属性 `textContent` 的表达式中使用, 因此Angular创建了一个绑定并将其与 `span` 元素相关联:

![time与span元素相关联](../assets/135/5.png)

> 在实际的实现中绑定并不是具有所有必需信息的单个对象, `viewDefinition` 定义了模板元素的实际绑定和要更新的属性,而用于绑定的表达式放在updateRenderer函数中。

## 检查组件视图

如您所知，Angular中的每个组件都会执行变更检测，而现在我们知道组件内部表示为 `View`，我们可以说每个视图都执行了变更检测

当Angular检查 `View` 时，它只是运行编译器为 `View` 生成的所有绑定。它计算表达式并将其结果与存储在 `View` 上 `oldValues` 数组中的值进行比较。这就是脏检查其名的来源。 如果它检测到差异，则更新与绑定相关的DOM属性并将新的值放入 `View` 中的 `oldValues` 数组中。这就是全部啦，你现在有了更新的UI。一旦Angular完成了对于当前组件的检查，它就会为子组件重复完全相同的变更检测步骤。

在之前的应用中，只有一个绑定到 App组件中的 span元素 的属性 `textContent`。因此在变更检测期间，Angular会读取组件属性 `time` 的值，应用 `date` 管道，并将其与存储在 `View` 上的前值进行比较。如果它检测到差异，Angular将更新span的 `textContent`属性和oldValues数组的内容。

### 但是错误从何而来？

在开发模式的条件下，每个变更检测周期之后，Angular会同步运行另一个检查以确保表达式生成与上一次变更检测运行期间的值相同。这个检查不是原始变更检测周期的一部分。它在完成对整个组件树的检查后运行，并执行完全相同的步骤。只是这次当Angular检测到差异时它不会更新DOM，而是抛出一个错误 `ExpressionChangedAfterItHasBeenCheckedError`

![同步的检测检测到了错误](../assets/135/6.png)

### 原因

现在我们知道了错误抛出的时间，但是为什么Angular需要这次检测呢？这样，我们想象一下，组件的某些属性在变更检测运行的期间发生了更新，作为结果，表达式产生了与渲染到用户界面的值不一样的新数据。那么此时Angular应该做什么？它当然可以运行另一个变更检测周期来同步应用和用户界面的状态。但是如果在此过程中某些属性再次更新了呢？发现了吗，Angular实际上可能会在无限循环的变更检测运行中走向终点。事实上，这种糟糕的情况在AngularJS中时常发生。

为了避免这种情况，Angular强加了所谓的单向数据流的模式。在变更检测之后运行的同步检查以及先前生成的  `ExpressionChangedAfterItHasBeenCheckedError` 错误是该强制机制的体现。一旦Angular处理了当前组件的绑定，你就不能再更新用于绑定表达式的组件的属性。